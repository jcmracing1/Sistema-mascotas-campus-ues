<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Ubicación de Mascotas - Campus (Multi)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;600;800&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#faf9f7; --card:#fff; --accent:#2b7cff; --danger:#ff4d4f; --radius:12px; --shadow:0 6px 18px rgba(0,0,0,0.08); }
    body{ margin:0; font-family:"Nunito",sans-serif; background:var(--bg); color:#222; }
    header{ text-align:center; padding:18px; font-weight:800; font-size:20px; }
    .pet-list{ display:flex; gap:12px; justify-content:center; flex-wrap:wrap; padding:8px 12px; }
    .pet-card{ background:var(--card); border-radius:10px; box-shadow:var(--shadow); width:160px; cursor:pointer; overflow:hidden; transition:transform .12s; display:flex; flex-direction:column; }
    .pet-card:hover{ transform:translateY(-6px); }
    .pet-card img{ width:100%; height:110px; object-fit:cover; display:block; }
    .pet-card .meta{ padding:8px; text-align:center; }
    .container{ max-width:1200px; margin:10px auto 40px; display:grid; grid-template-columns: 1fr 1fr 320px; gap:16px; padding:0 12px; }
    .photo, .desc, .mapcard, .controls, .history{ background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow); padding:12px; }
    .photo img{ width:100%; height:320px; object-fit:cover; border-radius:8px; }
    #map{ width:100%; height:460px; border-radius:8px; }
    .history{ height:460px; overflow:auto; }
    .entry{ padding:8px; border-radius:8px; border:1px solid #f0f0f0; margin-bottom:8px; cursor:pointer; display:flex; justify-content:space-between; align-items:center; }
    .badge{ padding:6px 8px; border-radius:8px; font-weight:700; font-size:13px; }
    .out{ background:var(--danger); color:#fff; }
    .in{ background:#38b000; color:#fff; }
    .controls .row{ margin-bottom:8px; }
    .top-actions{ display:flex; gap:8px; justify-content:center; margin-bottom:10px; }
    .btn{ padding:8px 12px; border-radius:8px; border:none; cursor:pointer; background:var(--accent); color:#fff; font-weight:700; }
    .btn.ghost{ background:#fff; border:1px solid #ddd; color:#222; }
    @media(max-width:1024px){ .container{ grid-template-columns: 1fr; } #map{ height:360px; } .history{ height:320px; } }
  </style>
</head>
<body>
  <header>Rastreo de mascotas - Campus UES (Multi-mascota)</header>

  <!-- Lista de mascotas -->
  <div class="pet-list" id="petList"></div>

  <div class="container">
    <div class="photo">
      <h2 id="petName">Nombre</h2>
      <img id="petPhoto" src="img/nessa.jpg" alt="foto mascota">
      <p id="petDesc" style="margin-top:10px; color:#444;">Descripción breve de la mascota.</p>
    </div>

    <div class="desc">
      <h3>Panel</h3>
      <div class="row"><strong>Última lat:</strong> <span id="lastLat">—</span></div>
      <div class="row"><strong>Última lng:</strong> <span id="lastLng">—</span></div>
      <div class="row"><strong>Altitud:</strong> <span id="lastAlt">—</span> m</div>
      <div class="row"><strong>Actualizado:</strong> <span id="lastTime">—</span></div>

      <div style="margin-top:12px;">
        <div class="top-actions">
          <button class="btn" id="btnShowAll">Mostrar todas</button>
          <button class="btn ghost" id="btnCenterCampus">Centrar campus</button>
        </div>
        <div id="statusAlert" style="margin-top:6px;color:#333;"></div>
      </div>
    </div>

    <aside class="controls">
      <h4>Control & Filtros</h4>
      <div class="row">
        <label>Resultados a traer:</label>
        <select id="selectResults"><option value="50">50</option><option value="100" selected>100</option><option value="200">200</option></select>
      </div>
      <div class="row">
        <label>Refresco (ms):</label>
        <input id="refreshMs" type="number" value="20000" style="width:100%; padding:8px; border-radius:8px; border:1px solid #ddd;">
      </div>
      <div class="row">
        <label>Último estado:</label>
        <div id="outOfCampusMsg" style="margin-top:6px;color:var(--danger); font-weight:700;"></div>
      </div>
    </aside>

    <section class="mapcard">
      <h3>Mapa</h3>
      <div id="map"></div>
    </section>

    <aside class="history">
      <h3>Historial</h3>
      <div id="historyList"></div>
    </aside>
  </div>

<script>
/* ========== CONFIGURACIÓN ========== */
// ThingSpeak (compartido)
const CHANNEL_ID = "3146056";
const READ_API_KEY = "GSRK8SFFHTSPZALK";

// Define aquí tus mascotas (nombre, foto, descripción, id esperado en field4/field5)
const pets = [
  { key: "nessa", name: "nessa", photo: "img/nessa.jpg", desc: "Perrita pitbull.", color:"#ff6b6b" },
  { key: "cleo",  name: "Cleo",  photo: "img/cleo.jpg",  desc: "perrita boxer mezclada en tratamiento por mareos.", color:"#4dabf7" },
  { key: "doguie", name: "Doguie", photo: "img/doguie.jpg", desc: "perrita french, en tratamiento por la edad avanzada.", color:"#ffd166" }
];

const campusPolygon = [
  [13.7233, -89.2032], // Esquina norte-oeste
  [13.7224, -89.1994], // Norte-este
  [13.7195, -89.1998], // Punto intermedio este
  [13.7165, -89.2003], // Sur-este
  [13.7152, -89.2060], // Sur-oeste
  [13.7192, -89.2055]  // Punto intermedio oeste
];

/* ========== Inicializar mapa ========== */
const map = L.map('map').setView([13.7008, -89.200], 15);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'&copy; OpenStreetMap contributors' }).addTo(map);
const campusPolyLayer = L.polygon(campusPolygon, { color:'#2b7cff', weight:2, fillOpacity:0.03 }).addTo(map);
map.fitBounds(campusPolyLayer.getBounds().pad(0.2));

/* ========== Estado global ========== */
let markersByPet = {};     // key -> marker
let polyByPet = {};        // key -> polyline
let pointsByPet = {};      // key -> [ {lat,lng,alt,ts} ]
let allMarkersLayer = L.layerGroup().addTo(map);
let showAllMode = false;
let refreshInterval = null;

/* ========== Utils ========== */
// Ray-casting point-in-polygon
function pointInPolygon(point, vs){
  const x = point[0], y = point[1];
  let inside = false;
  for (let i=0, j=vs.length-1; i<vs.length; j=i++){
    const xi = vs[i][0], yi = vs[i][1];
    const xj = vs[j][0], yj = vs[j][1];
    const intersect = ((yi>y) !== (yj>y)) && (x < (xj-xi) * (y-yi) / (yj-yi + 0.0) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function formatDate(iso){ if(!iso) return '—'; return new Date(iso).toLocaleString(); }

/* ========== Construir UI: lista de mascotas ========== */
const petListEl = document.getElementById('petList');
pets.forEach((p, idx) => {
  pointsByPet[p.key] = [];
  const card = document.createElement('div');
  card.className = 'pet-card';
  card.innerHTML = `<img src="${p.photo}" alt="${p.name}"><div class="meta"><strong>${p.name}</strong><div style="font-size:13px;color:#666;margin-top:6px">${p.desc}</div></div>`;
  card.onclick = ()=>loadPet(p.key);
  petListEl.appendChild(card);
});

/* ========== Fetch y procesamiento de feeds (agrupa por field4/field5) ========== */
async function fetchFeeds(results=100){
  const url = `https://api.thingspeak.com/channels/${CHANNEL_ID}/feeds.json?api_key=${READ_API_KEY}&results=${results}`;
  const res = await fetch(url);
  return res.json();
}

function resetPetData(){
  for(const p of pets){
    pointsByPet[p.key] = [];
    if(polyByPet[p.key]) polyByPet[p.key].setLatLngs([]);
    if(markersByPet[p.key]) { map.removeLayer(markersByPet[p.key]); markersByPet[p.key]=null; }
  }
  allMarkersLayer.clearLayers();
}

async function updateAll(){
  try{
    const results = parseInt(document.getElementById('selectResults').value || 100);
    const data = await fetchFeeds(results);
    if(!data || !data.feeds) return;

    if(!live) resetPetData(); // solo borra todo si no estamos en modo live

    // maps petKey -> points
    const assigned = {};
    // If device sends pet identifier in field4 or field5, use it.
    // field1 = lat, field2 = lng, field3 = alt (convention)
    data.feeds.forEach(f => {
      const lat = parseFloat(f.field1);
      const lng = parseFloat(f.field2);
      const alt = f.field3 ? parseFloat(f.field3) : null;
      const id = (f.field4 || f.field5 || "").trim();
      if(!lat || !lng) return;

      if(id){
        // if id matches any pet.key or pet.name (case-insensitive), assign
        const petMatch = pets.find(p => p.key.toLowerCase() === id.toLowerCase() || p.name.toLowerCase()===id.toLowerCase());
        if(petMatch){
          pointsByPet[petMatch.key].push({lat,lng,alt,ts:f.created_at});
          assigned[f.entry_id] = true;
          return;
        }
      }

      // otherwise keep in a bucket "unassigned"
      if(!pointsByPet["_unassigned"]) pointsByPet["_unassigned"] = [];
      pointsByPet["_unassigned"].push({lat,lng,alt,ts:f.created_at});
    });

    // If there are unassigned points and pets have no assigned data, distribute fallback:
    const un = pointsByPet["_unassigned"] || [];
    if(un.length > 0){
      // Strategy: if every pet has no points, give last unassigned to first pet, etc.
      const petsWithData = pets.filter(p=>pointsByPet[p.key] && pointsByPet[p.key].length>0);
      if(petsWithData.length === 0){
        // distribute latest unassigned point to all pets (fallback)
        const last = un[un.length-1];
        pets.forEach(p => pointsByPet[p.key].push(last));
      } else {
        // else attach unassigned points to the most recent pet nearby (optional) — simple: ignore extra
      }
    }

    // Now render each pet: polyline, last marker, check campus
    for(const p of pets){
      const pts = pointsByPet[p.key] || [];
      if(pts.length === 0) continue;
      // sort by timestamp asc
      pts.sort((a,b)=> new Date(a.ts) - new Date(b.ts));
      // store
      pointsByPet[p.key] = pts;

      // polyline
      const coords = pts.map(x=>[x.lat,x.lng]);
      if(polyByPet[p.key]) polyByPet[p.key].setLatLngs(coords);
      else polyByPet[p.key] = L.polyline(coords, { color: p.color, weight:3 }).addTo(map);

      // last marker
      const last = pts[pts.length-1];
      if(markersByPet[p.key]) { markersByPet[p.key].setLatLng([last.lat,last.lng]); }
      else {
        markersByPet[p.key] = L.circleMarker([last.lat,last.lng], { radius:8, color:p.color, fillColor:p.color, fillOpacity:1 }).addTo(map);
        markersByPet[p.key].bindPopup(`<strong>${p.name}</strong><br>${formatDate(last.ts)}<br>Lat: ${last.lat.toFixed(6)}<br>Lng: ${last.lng.toFixed(6)}`);
      }

      // update UI for currently selected pet (if loaded)
      const selected = document.getElementById('petName').textContent;
      if(selected === p.name){
        document.getElementById('petPhoto').src = p.photo;
        document.getElementById('petDesc').textContent = p.desc;
        document.getElementById('lastLat').textContent = last.lat.toFixed(6);
        document.getElementById('lastLng').textContent = last.lng.toFixed(6);
        document.getElementById('lastAlt').textContent = last.alt !== null ? last.alt.toFixed(2) : '--';
        document.getElementById('lastTime').textContent = formatDate(last.ts);
      }

      // check if last is inside campus
      const inside = pointInPolygon([last.lat, last.lng], campusPolygon);
      // show small badge on list (update pet-card background)
      // find the pet-card by comparing img alt or inner text
      // (simple method: update status area)
      if(!inside){
        document.getElementById('outOfCampusMsg').textContent = `${p.name} está FUERA del campus!`;
        document.getElementById('outOfCampusMsg').style.color = 'var(--danger)';
      } else {
        // if no pet out then clear message (we'll set it at end)
      }
    }

    // Centering behavior: if not showAllMode, fit bounds to selected pet
    if(!showAllMode){
      const sel = document.getElementById('petName').textContent;
      const selectedPet = pets.find(x=>x.name === sel);
      if(selectedPet && pointsByPet[selectedPet.key] && pointsByPet[selectedPet.key].length>0){
        const b = L.latLngBounds(pointsByPet[selectedPet.key].map(p=>[p.lat,p.lng]));
        map.fitBounds(b.pad(0.2));
      }
    } else {
      // show all: fit bounds to all polylines
      const allCoords = [];
      pets.forEach(p => {
        (pointsByPet[p.key]||[]).forEach(pt => allCoords.push([pt.lat,pt.lng]));
      });
      if(allCoords.length>0){
        const b = L.latLngBounds(allCoords);
        map.fitBounds(b.pad(0.2));
      }
      // also place markersByPet into allMarkersLayer for legend-like view
      allMarkersLayer.clearLayers();
      pets.forEach(p=>{
        if(pointsByPet[p.key] && pointsByPet[p.key].length>0){
          const last = pointsByPet[p.key][pointsByPet[p.key].length-1];
          const m = L.circleMarker([last.lat,last.lng], { radius:7, color:p.color, fillColor:p.color, fillOpacity:1 })
            .bindPopup(`<strong>${p.name}</strong><br>${formatDate(last.ts)}`);
          allMarkersLayer.addLayer(m);
        }
      });
    }

    // Update history list for selected pet
    const sel = document.getElementById('petName').textContent;
    const selectedPetObj = pets.find(x=>x.name === sel);
    if(selectedPetObj) renderHistory(pointsByPet[selectedPetObj.key] || []);

    // Update outOfCampusMsg if none out
    let anyOut = false;
    for(const p of pets){
      const pts = pointsByPet[p.key] || [];
      if(pts.length===0) continue;
      const last = pts[pts.length-1];
      if(!pointInPolygon([last.lat,last.lng], campusPolygon)){
        anyOut = true; break;
      }
    }
    if(!anyOut){
      document.getElementById('outOfCampusMsg').textContent = 'Todas las mascotas dentro del campus';
      document.getElementById('outOfCampusMsg').style.color = '#0b8457';
    }

  } catch(err){
    console.error("Error fetching ThingSpeak:", err);
  }
}

/* ========== Render historial de la mascota seleccionada ========== */
function renderHistory(points){
  const el = document.getElementById('historyList');
  el.innerHTML = '';
  if(!points || points.length===0){ el.innerHTML = '<div style="color:#999">No hay historial.</div>'; return; }
  const pts = [...points].reverse();
  pts.forEach(p=>{
    const div = document.createElement('div');
    div.className = 'entry';
    div.innerHTML = `<div>${formatDate(p.ts)}</div><div style="font-weight:700">${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}</div>`;
    div.onclick = ()=>{ map.setView([p.lat,p.lng],18); L.popup().setLatLng([p.lat,p.lng]).setContent(`${formatDate(p.ts)}<br>${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`).openOn(map); };
    el.appendChild(div);
  });
}

/* ========== Cargar datos de una mascota (cuando el usuario hace click) ========== */
function loadPet(key){
  const pet = pets.find(p=>p.key===key);
  if(!pet) return;
  // update UI immediate
  document.getElementById('petName').textContent = pet.name;
  document.getElementById('petPhoto').src = pet.photo;
  document.getElementById('petDesc').textContent = pet.desc;
  // run updateAll (will use selected name to update panel)
  updateAll();
}

/* ========== Controls ========== */
document.getElementById('btnShowAll').addEventListener('click', ()=>{
  showAllMode = !showAllMode;
  document.getElementById('btnShowAll').textContent = showAllMode ? 'Modo: Todas (ON)' : 'Mostrar todas';
  updateAll();
});
document.getElementById('btnCenterCampus').addEventListener('click', ()=>{
  map.fitBounds(campusPolyLayer.getBounds().pad(0.2));
});

/* ========== Primera carga y timer dinámico ========== */
(function init(){
  // set default selected pet
  document.getElementById('petName').textContent = pets[0].name;
  document.getElementById('petPhoto').src = pets[0].photo;
  document.getElementById('petDesc').textContent = pets[0].desc;

  // initial fetch
  updateAll();

  // set interval based on refreshMs input
function schedule(){
  const ms = parseInt(document.getElementById('refreshMs').value || 5000); // 5 segundos por defecto
  if(refreshInterval) clearInterval(refreshInterval);
  refreshInterval = setInterval(async ()=>{
    await updateAll(true); // modo "live"
  }, ms);
}
  
  schedule();
  document.getElementById('refreshMs').addEventListener('change', schedule);
  document.getElementById('selectResults').addEventListener('change', updateAll);
})();
</script>
</body>
</html>
